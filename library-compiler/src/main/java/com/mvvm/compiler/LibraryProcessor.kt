package com.mvvm.compiler

import com.google.auto.service.AutoService
import com.mvvm.annotation.AndroidEntryPoint
import com.mvvm.annotation.DaggerConstant
import com.mvvm.annotation.InjectViewBinding
import com.mvvm.annotation.InjectViewModel
import com.squareup.javapoet.*
import java.util.*
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.lang.model.util.Elements
import javax.lang.model.util.Types
import javax.tools.Diagnostic

/**
 * @author Yang Shihao
 */
@AutoService(Processor::class)
class LibraryProcessor : AbstractProcessor() {
    private var filer: Filer? = null
    private var messager: Messager? = null
    private var elementUtils: Elements? = null
    private var typeUtils: Types? = null
    private var options: Map<String, String>? = null

    @Synchronized
    override fun init(processingEnv: ProcessingEnvironment) {
        super.init(processingEnv)
        filer = processingEnv.filer
        messager = processingEnv.messager
        elementUtils = processingEnv.elementUtils
        typeUtils = processingEnv.typeUtils
        options = processingEnv.options
    }

    override fun getSupportedAnnotationTypes(): Set<String> {
        val set: MutableSet<String> = HashSet()
        set.add(AndroidEntryPoint::class.java.canonicalName)
        return set
    }

    override fun getSupportedSourceVersion(): SourceVersion {
        return SourceVersion.latestSupported()
    }

    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
        val packageNameSet = AnnotationFieldFeatureSet(roundEnv, options!!)
        // 类的集合
        val elements = getTypeElementsByAnnotationType(annotations, roundEnv)
        for (typeElement in elements) {
            val annotationMeta =
                AnnotationMeta(elementUtils!!, typeUtils!!, packageNameSet, typeElement)
            val className =
                ClassName.get(annotationMeta.packageName, annotationMeta.annotatedClassName)
            val staticMethodBuilder = MethodSpec.methodBuilder(DaggerConstant.STATIC_METHOD_NAME)
                .addModifiers(Modifier.PUBLIC)
                .addModifiers(Modifier.STATIC)
                .returns(TypeName.VOID)
                .addParameter(className, AnnotationMeta.PARAMS_NAME_ACTIVITY)
            annotationMeta.getFieldList().forEach {
                it.apply {
                    when (annotationType) {
                        InjectViewBinding::class.java.canonicalName -> {
                            staticMethodBuilder.addStatement(
                                "\$N.\$N = \$N.inflate(\$N.getLayoutInflater())",
                                AnnotationMeta.PARAMS_NAME_ACTIVITY,
                                filedName,
                                filedType,
                                AnnotationMeta.PARAMS_NAME_ACTIVITY
                            )
                        }
                        InjectViewModel::class.java.canonicalName -> {
                            staticMethodBuilder.addStatement(
                                "\$N.\$N = new androidx.lifecycle.ViewModelProvider(\$N).get(\$N.class)",
                                AnnotationMeta.PARAMS_NAME_ACTIVITY,
                                filedName,
                                AnnotationMeta.PARAMS_NAME_ACTIVITY,
                                filedType
                            )
                        }
                        else -> {
                            staticMethodBuilder.addStatement(
                                "\$N.\$N = new \$N()",
                                AnnotationMeta.PARAMS_NAME_ACTIVITY,
                                filedName,
                                filedType
                            )
                        }
                    }
                }
            }
            // 生成类
            val typeBuild = TypeSpec.classBuilder(annotationMeta.generateClassName)
                .addJavadoc("Generated by Library")
                .addModifiers(Modifier.PUBLIC)
            typeBuild.addMethod(staticMethodBuilder.build())
            try {
                JavaFile.builder(annotationMeta.packageName, typeBuild.build()).build()
                    .writeTo(filer)
            } catch (e: Exception) {
                messager!!.printMessage(Diagnostic.Kind.ERROR, e.message, typeElement)
            }
        }
        return true
    }

    /**
     * 获取被注解的类
     */
    private fun getTypeElementsByAnnotationType(
        annotations: Set<TypeElement>,
        roundEnv: RoundEnvironment
    ): Set<TypeElement> {
        val typeElements: MutableSet<TypeElement> = HashSet()
        val elements = roundEnv.rootElements
        for (element in elements) {
            if (element is TypeElement) {
                var found = false
                for (annotationMirror in element.getAnnotationMirrors()) {
                    for (annotation in annotations) {
                        if (annotationMirror.annotationType.asElement() == annotation) {
                            typeElements.add(element)
                            found = true
                            break
                        }
                    }
                    if (found) {
                        break
                    }
                }
            }
        }
        return typeElements
    }
}